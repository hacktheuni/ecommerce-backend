generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma/client"
}

datasource db {
  provider = "postgresql"
}

enum ProductStatus {
  AVAILABLE
  PENDING // e.g. interested / hold
  SOLD
  ARCHIVED
}

enum Condition {
  NEW
  LIKE_NEW
  USED
  FOR_PARTS
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  role         String   @default("user")
  refreshToken String?
  name         String?
  phoneNumber  String?
  bio          String?
  isVerified   Boolean  @default(false)
  createdAt    DateTime @default(now())

  // relations
  cartItems     CartItem[]
  orders        Order[]
  reviews       Review[]
  wishlistItems WishlistItem[]

  // marketplace relations
  products            Product[]      @relation("SellerProducts")
  buyerConversations  Conversation[] @relation("BuyerConversations")
  sellerConversations Conversation[] @relation("SellerConversations")
  messages            Message[]      @relation("UserMessages")
  reports             Report[]       @relation("UserReports")
  payments            Payment[]
}

model Product {
  id       String @id @default(uuid())
  seller   User   @relation("SellerProducts", fields: [sellerId], references: [id])
  sellerId String

  title        String        @unique
  description  String?
  price        Decimal       @db.Decimal(10, 2)
  stock        Int?          @default(1)
  status       ProductStatus @default(AVAILABLE)
  condition    Condition?
  isNegotiable Boolean       @default(false)
  category     String?
  city         String? 
  state        String?
  country      String? 
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  views        Int           @default(0)

  // relations
  images        ProductImage[]
  cartItems     CartItem[]
  orderItems    OrderItem[]
  reviews       Review[]
  wishlistItems WishlistItem[]
  conversations Conversation[] // conversations about this product
  reports       Report[]
}

model ProductImage {
  id        String   @id @default(uuid())
  product   Product  @relation(fields: [productId], references: [id])
  productId String
  url       String
  path      String
  altText   String?
  order     Int      @default(0)
  createdAt DateTime @default(now())
}

model CartItem {
  id        String  @id @default(uuid())
  user      User    @relation(fields: [userId], references: [id])
  userId    String
  product   Product @relation(fields: [productId], references: [id])
  productId String
  quantity  Int     @default(1)

  @@unique([userId, productId]) // one row per product per user
}

model Order {
  id                    String        @id @default(uuid())
  user                  User          @relation(fields: [userId], references: [id])
  userId                String
  status                String        @default("pending")
  totalAmount           Decimal       @db.Decimal(10, 2)
  shippingAddr          String?
  paymentStatus         PaymentStatus @default(PENDING)
  stripeSessionId       String?       @unique
  stripePaymentIntentId String?       @unique
  idempotencyKey        String        @unique
  paidAt                DateTime?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  items    OrderItem[]
  payments Payment[]
}

model OrderItem {
  id              String  @id @default(uuid())
  order           Order   @relation(fields: [orderId], references: [id])
  orderId         String
  product         Product @relation(fields: [productId], references: [id])
  productId       String
  productName     String
  priceAtPurchase Decimal @db.Decimal(10, 2)
  quantity        Int
}

model Review {
  id        String  @id @default(uuid())
  user      User    @relation(fields: [userId], references: [id])
  userId    String
  product   Product @relation(fields: [productId], references: [id])
  productId String

  rating    Int
  comment   String?
  createdAt DateTime @default(now())

  @@unique([userId, productId])
}

model WishlistItem {
  id        String  @id @default(uuid())
  user      User    @relation(fields: [userId], references: [id])
  userId    String
  product   Product @relation(fields: [productId], references: [id])
  productId String

  createdAt DateTime @default(now())

  @@unique([userId, productId])
}

model Conversation {
  id String @id @default(uuid())

  product   Product @relation(fields: [productId], references: [id])
  productId String

  // buyer & seller are nullable, each side stores its FK
  buyer   User   @relation("BuyerConversations", fields: [buyerId], references: [id])
  buyerId String

  seller   User   @relation("SellerConversations", fields: [sellerId], references: [id])
  sellerId String

  createdAt DateTime @default(now())

  messages Message[] // opposite side is Message.sender with the relation name "UserMessages"
}

model Message {
  id String @id @default(uuid())

  conversation   Conversation @relation(fields: [conversationId], references: [id])
  conversationId String

  sender   User   @relation("UserMessages", fields: [senderId], references: [id])
  senderId String

  content   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
}

model Report {
  id String @id @default(uuid())

  reporter   User   @relation("UserReports", fields: [reporterId], references: [id])
  reporterId String

  product   Product @relation(fields: [productId], references: [id])
  productId String

  reason    String
  details   String?
  resolved  Boolean  @default(false)
  createdAt DateTime @default(now())
}

model Payment {
  id                    String        @id @default(uuid())
  user                  User?         @relation(fields: [userId], references: [id])
  userId                String?
  order                 Order?        @relation(fields: [orderId], references: [id])
  orderId               String?
  amount                Decimal       @db.Decimal(10, 2) // amount in major currency unit (e.g., 49.99)
  currency              String        @default("USD") // store currency per-payment
  status                PaymentStatus @default(PENDING)
  stripePaymentIntentId String?       @unique
  stripeChargeId        String?       @unique
  paymentMethod         String? // optional: e.g., "card", "alipay"
  description           String? // free-form note
  metadata              Json? // store any Stripe response or metadata
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  refunds Refund[] // relations - refunds linked to this payment
}

model Refund {
  id             String   @id @default(uuid())
  payment        Payment  @relation(fields: [paymentId], references: [id])
  paymentId      String
  amount         Decimal  @db.Decimal(10, 2)
  currency       String   @default("USD")
  reason         String? // e.g., "requested_by_customer", "fraudulent", custom
  stripeRefundId String?  @unique
  status         String   @default("pending") // or create an enum if you prefer
  metadata       Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}
